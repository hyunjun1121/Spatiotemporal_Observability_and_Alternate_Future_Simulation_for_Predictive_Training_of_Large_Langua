# [Decisions v0 확정] (날짜: 2025-10-17)

- 목표 스케일/예산:
  - 모델: GPT-2 medium (~355M params) → Phase 1 검증용. 추후 GPT-2 large (~774M)로 확장.
  - 하드웨어 프로파일: 기본 1-node 4×GPU(24–48GB), 확장 1-node 8×GPU(40GB) 가정.
  - Precision: bf16(가능 시) 또는 fp16 + loss scaling.
- 데이터 & 노이즈(Instability Stressor):
  - 코퍼스: WikiText-103(Phase 1), 확장 시 C4 subset(10–50B tokens).
  - Synthetic 노이즈:
    - rare-token burst 2% 배치, very-long sequence 1% 배치,
    - unicode/segmentation artifacts 1% 배치,
    - block-wise shuffle(intra-epoch) 5% 구간,
    - aggressive warmup(초기 500 steps)로 grad spike 유발.
- Uncertainty Index:
  - 윈도: W=512 steps, EMA decay=0.98.
  - 가중치: w_vol=0.5, w_entropy=0.3, w_disagree=0.2.
  - 임계치 τ=2.5 z-score, 히스테리시스: 연속 3-step 초과 또는 단발 3.2 z 초과 시 발동.
- Proxy(Training Dynamics) horizon & 샘플:
  - Horizon N=2000 steps, 후보 M=128 actions, Top-K=6 실사 검증(+50 steps real rollout).
  - Accept/Reject: predicted risk quantile < 0.2 AND short rollout에서 volatility 감소 또는 val loss 개선.
- Action Space:
  - 필수: ΔLR ∈ {−20%, −10%, +0%, +10%}, weight_decay ×{0.5,1,2}, clip policy ∈ {ZClip, ARC, None}, momentum_reset ∈ {0,1}.
  - 선택: data_reorder ∈ {none, shuffle_block}, skip_batch ∈ {0,1}(기본 off, 연구용만 on).
- Checkpoint 정책:
  - 주기 every 1k steps, 보존 창 last 8, 포맷 zstd, optimizer moments 8-bit.
  - 저장: RNG/샘플러/LR 스케줄러/epoch/global_step/요약통계 포함(activation은 summary만).
- 평가 주기:
  - 1차 메트릭 every 1k steps, full eval every 10k steps.
  - Regression trigger: val pplx 1.5σ 악화(2회 연속) 또는 instability rate baseline 대비 +25%.

# 연구 통합 정리 및 진행 로그

본 문서는 다음 세 가지 소스의 내용을 단계적으로 통합·정리하고, 구현 계획과 열린 질문을 축적하는 진행 로그입니다.
- 아이디어 개요: 시공간적 옵저버빌리티 연구 아이디어 검토 및 발전.pdf
- 실행 지침: 연구 수행 순서 및 세부 지침.md
- 선행연구 활용: 각 논문 요약 및 활용 포인트.md (+ related_work/papers/*.md 상세)

업데이트 방식: 파일을 읽고 파악한 내용을 아래 섹션에 계속 추가/보완합니다. 이후 구현 단계별 체크리스트와 질문을 누적합니다
---

## 1) 프로젝트 핵심 아이디어 요약 (아이디어 PDF 기반)

- 핵심 문제의식: 대규모 언어모델(LLM) 프리트레이닝/파인튜닝 과정의 불안정성(spike/divergence)과 단기 지표에 매몰되는 myopic 업데이트를 극복하기 위해, 학습 과정을 “시공간적으로 관찰 가능한 상태(state)로 재정의”하고, 불확실성 신호에 반응해 “대안적 미래(Alternate Futures)”를 빠르게 탐색·수렴하는 체계를 제안.
- 주요 구성요소:
  - Uncertainty Index(트리거): 단기 변동성, 내부 엔트로피, 예측 불일치 등을 합성하여 이상 징후를 조기 감지.
  - Quantum Checkpointing: 핵심 상태벡터(state vector)를 경량·빈번하게 보존하여, 문제 발생 시 과거 지점으로의 되돌림과 분기(branch) 시뮬레이션을 저비용으로 수행.
  - Proxy(Training Dynamics World Model): (state, action) → 미래 지표(손실, 불안정 위험 등)를 단기 예측하는 대리모델로, 계획(planning)·탐색을 가속.
  - Branch Simulation Orchestrator: Proxy로 폭넓게 사전 평가한 후보 중 Top-K를 실제 짧은 롤아웃으로 검증(accept/reject)하고, 최적 대안을 본선에 “붕괴(collapse)”시켜 이어감.
- 방법적 영감:
  - 시간 병렬성(Time-parallelism) / Population 기반 탐색과 자원 재배치
  - Speculative Decoding의 “draft→target 검증” 개념을 학습 시나리오로 이식해, 분기 대안을 빠르게 검증·수용
  - MuZero식 단기 모델 기반 계획(MCTS 유사 사고방식)으로 Proxy 롤아웃 활용
- 기대효과: 불안정 스파이크 감소, 회복 시간 단축, 낭비 FLOPs 절감, 장기 성능(Val pplx) 저하 없이 안정성·효율성 동시 개선

---

## 2) 실행 순서 및 세부 지침 요약 (구현 로드맵)

- 리포 구조(요지): `related_work/`(선행연구), `src/`(train/ monitor/ proxy/ branch/ cp/ eval/), `runs/`, `branches/`, `assets/`, `notes/`
- Phase 1: Baseline 준비
  - 모델: GPT-2 med/large 혹은 T5-base(open weights)
  - 데이터: 공개 코퍼스 + 불안정 유발 synthetic 노이즈로 스트레스 테스트 구성
  - 트레이너: PyTorch DDP, bf16 mixed precision
  - 결정론 복원: RNG/샘플러/LR 스케줄러 등 상태를 `assets/state_schema_v1.yaml`로 정의·저장
- Quantum Checkpointing
  - 주기: 기본 1k step (configurable)
  - 포맷: `cp_{global_step}.ptz`(zstd 등), 옵티마이저 모멘트 8-bit 양자화 옵션, activation은 통계요약(평균/표준편차/엔트로피) 위주
- Uncertainty Index(Trigger)
  - 3축: 단기 변동성(loss EMA residual, grad norm), 내부 상태 엔트로피(어텐션/핵심 레이어), 예측 불일치(N-step loss forecast 분산)
  - 가중합 지수·스레시홀드를 `assets/uncertainty_config.yaml`에서 관리, 임계 초과 시 분기 시뮬레이션 진입
- Proxy(Training Dynamics)
  - 입력 특성: 스칼라(loss, grad_norm, lr, wd, clip, momentum_reset, batch stats), 벡터 요약(레이어별 activation/attention entropy), 과거 지표의 EMA/분산 등
  - 액션 인코딩: lr ±, wd ×/÷, 클리핑(ZClip/ARC/SPAM-clip), momentum reset, data reorder, skip_batch 등
  - 목표: E[loss@+N], P(divergence@+N), instability risk, recovery time
  - 학습 데이터: baseline run 로그 튜플(state, action, future metrics) → parquet/JSON 스키마화
  - 보정: conformal prediction으로 위험 분위수 캘리브레이션
- Branch Simulation Orchestrator
  - 트리거 시 `cp_{t-1000}` 로드 → 액션 탐색(그리드/BO/밴딧, 50~500 샘플) → Proxy 롤아웃 점수화
  - Top-K(5~10) 실사 단기 롤아웃(+50 step 등)으로 검증(accept/reject) → 최상 대안 본선에 붕괴
  - `branches/{t}/decision.json` 등 메타·근거 기록
- 평가
  - 1차: Val pplx, instability/100k steps, time-to-recover, wasted FLOPs
  - 2차: branch invoke rate, partial→full 수용률, proxy-실측 갭, draft-target 검증 비용 등

---

## 3) 관련 연구 정리 및 모듈 매핑

아래는 각 논문에서 차용할 핵심 아이디어와 본 프레임워크 내 적용 위치입니다. (상세는 `related_work/papers/*.md` 참조)

- Population Based Training(PBT)
  - 적용: baseline 대비 분기 탐색의 compute 효율성 비교 기준 설정, exploit/explore 스케줄링 아이디어를 분기 오케스트레이션에 혼합
  - 위치: Branch Orchestrator(액션 풀 생성·자원 재배치 전략)
- Speculative Decoding 계열(Leviathan 등)
  - 적용: Proxy를 ‘draft’, 실제 단기 롤아웃을 ‘verification’로 보고 accept/reject 규칙·캘리브레이션 설계
  - 위치: Branch Orchestrator(Top-K 검증·수용), Proxy 캘리브레이션
- MuZero
  - 적용: Proxy를 world model로 바라보고 단기 롤아웃 기반 계획/평가(MCTS 유사)로 분기 점수화
  - 위치: Proxy 설계 및 시뮬레이션 루프
- Learning Curve Extrapolation(LCE)
  - 적용: 값싼 학습곡선 예측으로 초기 후보 가지치기(pruning) 및 조기중단 판단
  - 위치: Proxy 보조 예측기/Heuristic 필터
- Hypergradient Descent
  - 적용: lr 상·하향 제안 생성, proxy 입력 특성(하이퍼그래디언트) 포함
  - 위치: 액션 제안기, Feature 엔지니어링
- Learned Optimizer(L2L by GD)
  - 적용: meta-learned dynamics/optimizer를 proxy·탐색 컴포넌트에 실험적으로 결합
  - 위치: Proxy/Optimizer 대체 실험
- Activation Checkpointing / RevNet
  - 적용: 상태벡터 I/O·메모리 발자국 축소, 재현가능 체크포인트 비용 최소화
  - 위치: Quantum Checkpointing, 모델 구조 선택 가이드
- Stabilizing LLM Pretraining(2024)
  - 적용: 손실 스파이크 진단 신호(gradient/activation/LN 등)를 Uncertainty Index에 반영
  - 위치: Monitor/Trigger 설계
- SPAM(2025), ZClip(2025), ARC(2025)
  - 적용: 스파이크 대응 클리핑·모멘텀 리셋을 액션 공간에 포함, Z-score 기반 이상감지와 연동
  - 위치: 액션 인코딩, Monitor-Policy 연계

---

## 4) 초기 구현 체크리스트

- [ ] `assets/state_schema_v1.yaml` 상태벡터 초안 작성(모델/옵티마이저/LR/모든 RNG/샘플러/스텝/요약통계)
- [ ] `src/cp/` 체크포인트 저장·복원 모듈 스켈레톤 (zstd, 8-bit moments 옵션)
- [ ] `src/monitor/` Uncertainty Index v0(EMA 기반 지표 + 임계치 구성, 로깅)
- [ ] `src/proxy/` 특징 생성 파이프라인 + 간단 MLP 예측기 + conformal 캘리브레이션 훅
- [ ] `src/branch/` 분기 오케스트레이터(액션 샘플링→Proxy 스코어→Top-K 실사→결정 기록)
- [ ] 로그 스키마(`assets/log_schema.json`) 및 런 DB(`runs/log_db.parquet`) 적재 유틸
- [ ] 메트릭 대시보드 초안(불안정 이벤트율, 회복시간, wasted FLOPs 등)

---

## 5) 열린 질문 / 의사결정 포인트

1) 목표 스케일과 예산
- 1B 파라미터급까지 가정해도 될까요? 단일/다중 GPU 환경, 예상 학습 시간·비용 범위를 알려주시면 분기 실험 폭을 조정하겠습니다.

2) 데이터셋 및 불안정 유발 노이즈
- 사용 예정 코퍼스(예: WikiText103, C4 등)와 데이터 정제/샘플링 정책은 무엇인가요?
- “instability 스트레스 테스트”에 투입할 synthetic 노이즈의 구체 예(난도, 비율, 주입 위치)를 확정해 주실 수 있을까요?

3) Uncertainty Index 설계 우선순위
- 세 축(단기 변동성/내부 엔트로피/예측 불일치) 중 어떤 신호를 1차 릴리즈에서 가장 민감하게 볼까요?
- 초기 임계치, EMA decay, 윈도 크기 등 기본값 선호가 있을까요?

4) Proxy Horizon과 정확도-비용 트레이드오프
- N(step horizon)과 분기 샘플 수(50~500) 기본값을 어떤 범위에서 시작할까요?
- Proxy 예측 신뢰구간 기반의 accept/reject 정책을 얼마나 보수적으로 설정할까요?

5) 액션 공간 구성
- LR/WD/클리핑/모멘텀리셋/데이터재배열/스킵배치 중 필수·선택을 구분해 주실 수 있을까요?
- ZClip/ARC/SPAM-clip 중 기본 클리핑 정책의 우선순위는?

6) 체크포인트 예산·보존 정책
- 체크포인트 주기(1k 기준)와 보존 창(window) 크기, 압축·정밀도(8-bit moments) 허용 범위를 정해도 될까요?

7) 평가·보고 주기
- 1차·2차 메트릭 수집 주기(예: 1k/5k/10k step)와 리그레션 임계치를 어떻게 둘까요?

---

## 6) 진행 로그

- 초기 스캔: 루트 2개 MD와 아이디어 PDF, related_work/papers/*.md 인덱스 확인
- 통합 초안 작성: 아이디어 요약, 실행 지침 요약, 관련 연구 매핑, 체크리스트/질문 등록
